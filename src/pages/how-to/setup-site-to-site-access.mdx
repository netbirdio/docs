import {Note} from "@/components/mdx";

# Setting up Site-to-Site/VPN access over NetBird

On this page you will learn the characteristics of **Site-to-Site**, **Site-to-VPN** and **VPN-to-Site** setups and how to achieve
them with NetBird. We will start by establishing some terminology and provide overview of the setup options before
jumping into a concrete implementation examples using NetBird.

## Overview

A **Site** in the context of this guide can be any single network/subnet that is often neither exposed to the
Internet, nor directly accessible from other **Sites**, but can be. To give some examples a **Site** could be:

- home or office network,
- an internal network at the cloud provider or datacenter,
- a restricted VLAN,
- an internal container or VM networking range,
- other VPN's networking range,
- another NetBird organization's resources ranges,
- and many more...

A **device** in the context of this guide can be any kind of physical
(a PC, laptop, phone, a server in the datacenter etc.) or virtual computing device
(a VM, container, load balancer etc.). A **device** can be either **clientless** or a **Peer**.


A **clientless** devices are all **devices**, which don't run a NetBird client themselves (are not **Peers**).

A **Peer** in the context of this guide matches the general NetBird definition of a **device** running NetBird client
directly on it:

- a laptop running NetBird client directly on the system is a **Peer**,
- a laptop running NetBird client in a container in a default (internal) networking mode is not a **Peer**.
  The container itself is the **Peer** in this case.
- a laptop running NetBird client in a container in host-networking mode could be considered a **Peer**,

Other **bold** terms are used for NetBird-specific features or configuration options, such as:
**Network Route**, **Network**, **Resource**, **Access Control Policy**, **ACL Group**.

Terms without any styling usually refer to context specific terms, such as:
- a route: used as a generic term representing operating system network route,
- a resource: used as a generic term representing a software or machine listening on specific IP address and port,


### Site-to-Site

We are talking about a **Site-to-Site** setup when **clientless** devices from 2 or more **Sites** can reach each other.
A set of at least one **Peer** per **Site** is required to route the traffic over the VPN, but other on-site devices
do not need to run (or be aware of) the VPN software themselves.

The **clientless** devices still need to be told to route the remote **Site**'s IP addressing range through the local 
**Peer**. It can be configured manually with commands and persisted using the specific Operating System's facilities or
automated with DHCP advertisements or device management software.

The remote **Peer** needs to know how to route the answers back to the local **Site**.
You will usually need to set up a pair of routes to access each site:

1. a route from local **Peer** to remote **Site** to call out to it,
2. a reverse route from remote **Site** to the local **Peer** to receive the answers,

### Site-to-VPN

We are talking about a **Site-to-VPN** setup when a **clientless** device can reach **Peers** in the VPN network.

You can think of it as the local half of the **Site-to-Site** setup. The **clientless** devices still need to be told
how to reach the VPN network, but usually no additional setup is required to route the answers back from the VPN.

### VPN-to-Site

We are talking about a **VPN-to-Site** setup when a **Peer** can reach out to **clientless** devices on a network
external to the VPN itself.
This is often the default mode of operation of most VPNs, but is still worth mentioning for completeness' sake.
In NetBird this scenario is achieved with any usage of **Networks** or (older) **Network Routes**.

## NetBird implementations overview

While NetBird does not _explicitly_ support a Site-to-VPN or Site-to-Site yet, it is possible to achieve those scenarios
with some caveats in following ways depending on your requirements:

1. Using a **Network Route** for each **Site** with Masquerade and with or without **ACL Groups**,
2. Using a **Network Route** for each **Site** without Masquerade and without **ACL Groups**,
3. Using a **Network** **Resource** with Masquerade,

All of the above options require that:

- you need to tell the **clientless** devices how to route the traffic yourself,
  - it is easiest done using device management software or additional DHCP route advertisements on the local router,
- you can only have one routing **Peer** within each **Site**,
  - it is very complex, if not outright impossible task to correctly and reliably route the traffic using multiple
    routing devices and therefore is out of the scope of this guide,

As the primary caveat you will need to either:

1. forfeit the Source IP addressing information by using Masquerade to preserve rudimentary form of Access Control,
  - Masqueraded traffic can only be policed by the Access Policies attached to the **Routing Peer** with no way to
    restrict access of any specific **clientless** device,
  - you can still create very coarse access controls by creating multiple **Network** **Routing Peers** for different
    purposes,
2. forfeit Access Control altogether (any traffic will be allowed) to preserve the Source IP addressing,
  - this might be mandatory in some specific networking setups,

## Prerequisites and initial assumptions

For this guide I will be running a set of 4 Ubuntu Virtual Machines backed by `libvirt` split into 2 separate **Sites**
(networks) as follows:
```shell
root@vms ~# virsh net-dhcp-leases local-site
... IP address           Hostname    ...
... ---------------------------------...
... 192.168.122.144/24   local-nb-01 ...
... 192.168.122.65/24    local-01    ...

root@vms ~# virsh net-dhcp-leases remote-site
... IP address           Hostname      ...
...------------------------------------...
... 192.168.100.189/24   remote-nb-01  ...
... 192.168.100.215/24   remote-01     ...
```

All VMs can be reached from the host `vms`:
```shell
kdn@pc ~> ssh vms.lan ping -c1 192.168.100.189
PING 192.168.100.189 (192.168.100.189) 56(84) bytes of data.
64 bytes from 192.168.100.189: icmp_seq=1 ttl=64 time=0.154 ms

--- 192.168.100.189 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.154/0.154/0.154/0.000 ms
kdn@pc ~> ssh vms.lan ping -c1 192.168.122.144
PING 192.168.122.144 (192.168.122.144) 56(84) bytes of data.
64 bytes from 192.168.122.144: icmp_seq=1 ttl=64 time=0.162 ms

--- 192.168.122.144 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.162/0.162/0.162/0.000 ms
```

Both **Sites** can reach the Internet and their devices can talk to each, but cannot directly call out to 
the other **Site**:

```shell
kdn@pc ~> ssh 192.168.100.189 -J vms.lan ping -c1 192.168.122.144
PING 192.168.122.144 (192.168.122.144) 56(84) bytes of data.
From 192.168.122.1 icmp_seq=1 Destination Port Unreachable

--- 192.168.122.144 ping statistics ---
1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms

kdn@pc ~ [1]>
```

The `local-site` network VMs are also directly attached to my LAN. The `remote-site` are only attached to their network,
so I need to reference them by IP addresses and use `vms` as SSH JumpHost:

Devices `local-01` and `remote-01` are **clientless** for purposes of this guide.
Additionally `remote-01` runs a CoreDNS, which responding with `OK` to `http://192.168.100.10/health`.

The **Peers** look as follows:

| dns_label      | netbird_ip       | groups              |
|----------------|------------------|---------------------|
| `local-nb-01`  | `100.83.73.97`   | `s2s: local peers`  |
| `remote-nb-01` | `100.83.136.209` | `s2s: remote peers` |

We will be granting access between:
- `local-01` running at a `local-site` through a **Routing Peer** `local-nb-01` using **Group** `s2s: local peers`,
- `remote-01` running at `remote-site` through a **Routing Peer**  `remote-nb-01` using **Group** `s2s: remote peers`,

<Note>
  This guide assumes working with Linux devices, but the commands used are relatively simple/cross-platform
  and should be possible to translate to other Operating System's facilities.
</Note>

## Site-to-Site with Masquerade

A **Masquerade** option means that packets forwarded by a **Routing Peer** will have:
- their source IP address replaced with the **Routing Peer**'s NetBird IP address when leaving the **Site**,
- translated back from the **Routing Peer**'s IP address to the local **Site**'s IP address when returning,

This is currently the easiest way to configure routing, because it utilizes already existing **Peer** forwarding
and policing facilities.

The main downsides of this approach are:

- losing the source addressing information, which might be mandatory for auditing purposes,
- very coarse-grained policing limited to the **Routing Peer**'s access controls,

### Site-to-Site using Network Routes with Masquerade and without Access Control

In this section we will set up **Network Routes** Site-to-Site with Masquerade, but without any Access Control.
We will start by setting up the required **Network Routes**, Access Policies and manually instructing a **clientless**
device to route traffic through the local **Routing Peer**, then finally confirm everything is working as expected.

#### Setting up a simple VPN-to-Site access

<p>
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/routes-noacl-vpn-to-site.png" alt="routes-noacl-vpn-to-site"
         className="imagewrapper-big"/>
</p>

and **Access Control Policy** simply establishing connectivity between the (future) **Routing Peers**:

<p id="unidirectional-routing-peer-policy">
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/acl-ping-to-local-only.png" alt="acl-ping-to-local-only"
         className="imagewrapper-big"/>
</p>

<Note>
  It doesn't matter that it's unidirection ICMP rule in the wrong direction as **Network Routes** get activated
  as soon as any kind of **Access Control Policy** initiates a connectivity to the **Routing Peer** as explained in
  [Network Routes caveats](/how-to/routing-traffic-to-private-networks#network-routes-caveats).
</Note>

We can confirm that we can reach the `remote-site` from the local **Peer** with both `ping` and `curl`:
```shell
kdn@pc ~> ssh local-nb-01.lan "netbird networks ls"
Available Networks:

  - ID: network-route-srvs-site
    Network: 192.168.122.0/24
    Status: Selected
    
kdn@pc ~> ssh local-nb-01.lan "ping -c1 192.168.100.10"
PING 192.168.100.10 (192.168.100.10) 56(84) bytes of data.
64 bytes from 192.168.100.10: icmp_seq=1 ttl=63 time=0.475 ms

--- 192.168.100.10 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.475/0.475/0.475/0.000 ms

kdn@pc ~> ssh local-nb-01.lan "curl 192.168.100.10/health; echo"
OK
```

#### Setting up the clientless device

We will now manually instruct **clientless** `local-01` device to route traffic to the `remote-site`
through `local-nb-01`'s local IP address `192.168.122.144`:
```shell
kdn@pc ~> ssh local-01.lan "ip route | grep 192.168.100"
kdn@pc ~ [1]> ssh local-01.lan "sudo ip route add 192.168.100.0/24 via 192.168.122.144"
kdn@pc ~> ssh local-01.lan "ip route | grep 192.168.100"
192.168.100.0/24 via 192.168.122.144 dev enp7s0 
```

<Note>
  This step makes sense to be done via a DHCP server's route advertisement, but it is out ouf the scope of this guide.
</Note>

This will not work just yet from a **clientless** device, because we are missing the other half of the connection to 
route back the answers:

```shell
kdn@pc ~> ssh local-01.lan "ping -c1 192.168.100.10"
PING 192.168.100.10 (192.168.100.10) 56(84) bytes of data.

--- 192.168.100.10 ping statistics ---
1 packets transmitted, 0 received, 100% packet loss, time 0ms

kdn@pc ~ [1]>
```

#### Closing the loop with reverse Network Route

We can now complete the setup by enabling the reverse **Network Route** (from `remote-site` to `local-site`):

<p id="routes-noacl-site-to-site">
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/routes-noacl-site-to-site.png" alt="routes-noacl-site-to-site"
         className="imagewrapper-big"/>
</p>

Let's confirm it is working for both ICMP and HTTP: 

```shell
kdn@pc ~> ssh local-01.lan "ping -c1 192.168.100.10"
PING 192.168.100.10 (192.168.100.10) 56(84) bytes of data.
64 bytes from 192.168.100.10: icmp_seq=1 ttl=62 time=0.867 ms

--- 192.168.100.10 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.867/0.867/0.867/0.000 ms
kdn@pc ~> ssh local-01.lan "curl 192.168.100.10/health; echo"
OK
```

#### Confirming remote Site access to the local Site

Let's fetch `local-01` IP address, perform the reverse setup on `remote-01` and test the
access back from `remote-site`:
```shell
kdn@pc ~> ssh local-01.lan "ip a | grep 192.168.122"
    inet 192.168.122.65/24 metric 100 brd 192.168.122.255 scope global dynamic enp7s0
kdn@pc ~> ssh 192.168.100.215 -J vms.lan "ip route | grep 192.168.122"
kdn@pc ~ [1]>  ssh 192.168.100.215 -J vms.lan "sudo ip route add 192.168.122.0/24 via 192.168.100.189"
kdn@pc ~> ssh 192.168.100.215 -J vms.lan "ip route | grep 192.168.122"
192.168.122.0/24 via 192.168.100.189 dev enp7s0
kdn@pc ~> ssh 192.168.100.189 -J vms.lan "ping -c1 192.168.122.65"
PING 192.168.122.65 (192.168.122.65) 56(84) bytes of data.
64 bytes from 192.168.122.65: icmp_seq=1 ttl=63 time=0.523 ms

--- 192.168.122.65 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.523/0.523/0.523/0.000 ms
kdn@pc ~>
```

### Site-to-Site using Network Routes with Masquerade and Access Control

We will start by picking up where we have finished the previous example
[Site-to-Site using Network Routes with Masquerade and without Access Control](#site-to-site-using-network-routes-with-masquerading-and-without-access-control).
We can now restrict the access to the remote **Site**'s resources to ICMP-only and confirm the limits are enforced.
We will start by setting up and verifying unidirectional access before making it work both ways.

First let's add a dedicated `* resources` Access Control Groups to the **Network Routes**:

<p>
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/routes-with-acl-site-to-site.png" alt="routes-with-acl-site-to-site"
         className="imagewrapper-big"/>
</p>

Take a note of using a different Group to grant access to the **Network Route** from one used for **Routing Peers**.
Using **Routing Peer**'s Group in ACL Groups would also work and be slightly simpler to manage.

<Note>
  Granting access just to the **Network Route**'s ACL Groups will still require at least one **Access Control Policy** 
  granting any kind of access directly to the **Routing Peer** to make the **Network Route** visible to the **Peer**
  making use of this route.

  This is in a stark contrast to Network Resources, where:
  - **Resource**'s **Groups** are tied to both access and discovery in a single step,
  - **Routing Peer** permissions are not required, unless you want to access its LAN IPs, 
</Note>
    
Secondly let's set up **Access Control Policies** for one-way access from the `local-site` to `remote-site`:

<p>
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/acl-unidirectional-site-to-site.png" alt="acl-unidirectional-site-to-site"
         className="imagewrapper-big"/>
</p>

Now we can confirm that `ping` (ICMP) is allowed, while `curl` (HTTP) is not in local-to-remote direction:

```shell
kdn@pc ~> ssh local-01.lan "ip route | grep 192.168.100"
192.168.100.0/24 via 192.168.122.144 dev enp7s0
kdn@pc ~> ssh local-01.lan "ping -c1 192.168.100.10"
PING 192.168.100.10 (192.168.100.10) 56(84) bytes of data.
64 bytes from 192.168.100.10: icmp_seq=1 ttl=62 time=0.738 ms

--- 192.168.100.10 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.738/0.738/0.738/0.000 ms
kdn@pc ~> ssh local-01.lan "curl -sv -m 2 192.168.100.10/health; echo"
*   Trying 192.168.100.10:80...

* Connection timed out after 2002 milliseconds
* closing connection #0
```

Let's also confirm that the reverse access is (from `remote-site` to `local-site`) not possible yet:

```shell
kdn@pc ~> ssh 192.168.100.215 -J vms.lan "ip route | grep 192.168.122"
192.168.122.0/24 via 192.168.100.189 dev enp7s0
kdn@pc ~> ssh 192.168.100.215 -J vms.lan "ping -c1 192.168.122.65"
PING 192.168.122.65 (192.168.122.65) 56(84) bytes of data.

--- 192.168.122.65 ping statistics ---
1 packets transmitted, 0 received, 100% packet loss, time 0ms

kdn@pc ~ [1]>
```

Finally, we can enable the `s2s: ping to local resources` **Access Control Policy**:

<p>
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/acl-bidirectional-site-to-site-minus-routing-peer.png" alt="acl-bidirectional-site-to-site-minus-routing-peer"
         className="imagewrapper-big"/>
</p>

<Note>
  We do not need to enable the reverse ICMP policy to the **Routing Peer**
  as explained [previously](#unidirectional-routing-peer-policy).
</Note>

And verify the remote-to-local access started working:

```shell
kdn@pc ~> ssh 192.168.100.215 -J vms.lan "ip route | grep 192.168.122"
192.168.122.0/24 via 192.168.100.189 dev enp7s0
kdn@pc ~> ssh 192.168.100.215 -J vms.lan "ping -c1 192.168.122.65"
PING 192.168.122.65 (192.168.122.65) 56(84) bytes of data.
64 bytes from 192.168.122.65: icmp_seq=1 ttl=62 time=0.755 ms

--- 192.168.122.65 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.755/0.755/0.755/0.000 ms
kdn@pc ~>
```

### Site-to-Site using Network Resources with Masquerade

In this section we will replicate the previous 
[Site-to-Site using Network Routes with Masquerade and Access Control](#site-to-site-using-network-routes-with-masquerading-and-access-control) 
configuration using **Network Resources** and verify that it's working. 
We will start by setting up a **Network** for each **Site**, 
enable the minimal set of (already existing) Access Policies required to make the setup work
and finally verify it is usable and enforced in practice.

Let's start by creating 2 new **Networks**, one for each **Site**:

<p>
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/network-local-noacl.png" alt="network-local-noacl"
         className="imagewrapper-big"/>
</p>

<p>
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/network-remote-noacl.png" alt="network-remote-noacl"
         className="imagewrapper-big"/>
</p>

and enable the 2 required **Access Control Policies**:

<p>
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/acl-networks-bidirectional.png" alt="acl-networks-bidirectional"
         className="imagewrapper-big"/>
</p>

<Note>
  Unlike **Network Routes**, you don't need policies granting access to the **Routing Peers**.

  On the other hand a reverse **Access Control Policy** is mandatory for **Resources**,
  otherwise the reverse route will not be advertised on the local client and therefore answering packets will be lost.
</Note>

Let's confirm it's working:

```shell
kdn@pc ~> ssh local-01.lan "ip route | grep 192.168.100"
192.168.100.0/24 via 192.168.122.144 dev enp7s0
kdn@pc ~> ssh local-01.lan "ping -c1 192.168.100.10"
PING 192.168.100.10 (192.168.100.10) 56(84) bytes of data.
64 bytes from 192.168.100.10: icmp_seq=1 ttl=62 time=0.783 ms

--- 192.168.100.10 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.783/0.783/0.783/0.000 ms
kdn@pc ~> ssh 192.168.100.215 -J vms.lan "ip route | grep 192.168.122"
192.168.122.0/24 via 192.168.100.189 dev enp7s0
kdn@pc ~> ssh 192.168.100.215 -J vms.lan "ping -c1 192.168.122.65"
PING 192.168.122.65 (192.168.122.65) 56(84) bytes of data.
64 bytes from 192.168.122.65: icmp_seq=1 ttl=62 time=0.925 ms

--- 192.168.122.65 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.925/0.925/0.925/0.000 ms
```

and that no additional traffic is allowed to pass through:

```shell
kdn@pc ~> ssh local-01.lan "curl -m 2 192.168.100.10/health; echo"
curl: (28) Connection timed out after 2002 milliseconds
```

#### Asymmetric Network Resource policies

The reverse **Access Control Policy** does not need to match the protocol and access level of the forward policy.
Already established connections will be routed back just fine as long as the reverse (operating system) route
is registered on the remote end.

<p>
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/acl-networks-bidirectional-assymetric.png" alt="acl-networks-bidirectional"
         className="imagewrapper-big"/>
</p>

We can now confirm that `local-site` can reach `remote-site` only over ICMP:

```shell
kdn@pc ~> ssh local-01.lan "ping -c1 192.168.100.10"
PING 192.168.100.10 (192.168.100.10) 56(84) bytes of data.
64 bytes from 192.168.100.10: icmp_seq=1 ttl=62 time=0.836 ms

--- 192.168.100.10 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.836/0.836/0.836/0.000 ms
kdn@pc ~ [1]> ssh local-01.lan "nc -v -w 2 192.168.100.10 22"
nc: connect to 192.168.100.10 port 22 (tcp) failed: Connection timed out
kdn@pc ~ [1]>
```

while `remote-site` can only reach `local-site` over SSH:

```shell
kdn@pc ~> ssh 192.168.100.215 -J vms.lan "ip route | grep 192.168.122"
192.168.122.0/24 via 192.168.100.189 dev enp7s0
kdn@pc ~> ssh 192.168.100.215 -J vms.lan "ping -c1 192.168.122.65"
PING 192.168.122.65 (192.168.122.65) 56(84) bytes of data.

--- 192.168.122.65 ping statistics ---
1 packets transmitted, 0 received, 100% packet loss, time 0ms

kdn@pc ~ [1]> ssh 192.168.100.215 -J vms.lan "nc -w 2 192.168.122.65 22"
SSH-2.0-OpenSSH_9.7p1 Ubuntu-7ubuntu4.3
kdn@pc ~>
```

## Site-to-Site without Masquerade

This approach allows you to preserve the source addressing information, but the traffic
will be instantly rejected by the remote **Routing Peer** as soon as you try to enable any kind of
**Access Control Policies** such as **Network Resources** or adding **ACL Groups** to **Network Routes**.

This happens because as of writing this guide all policing in NetBird is based on the **Peer**'s IP addressing.
Packets arriving from different addressing spaces (without Masquerade) are unknown to NetBird policy engine
and therefore instantly rejected on the receiving **Peer**/**Routing Peer**.

<Note>
  We aim to address current shortcomings in the future by implementing a dedicated set of facilities to set up and
  granularly policy Site-to-Site and Site-to-VPN scenarios.

  In the meantime you can still manually restrict the forwarded traffic using your operating system's firewall,
  for example by implementing a set of `FORWARD` policies in case of Linux.
</Note>

### Site-to-Site using Network Routes without Masquerade

In short you should be able to simply switch off Masquerade on each **Network Route** from
[the first example](#site-to-site-using-network-routes-with-masquerading-and-without-access-control).

To summarize, we will need to:
- a pair of local and remote **Network Routes**,
- an **Access Control Policy** to establish connectivity between **Routing Peers**,
- manually set up **clientless** devices with routes through the respective **Routing Peers**. 

The **Network Routes** list will look just like the [above](#routes-noacl-site-to-site):

<p>
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/routes-noacl-site-to-site.png" alt="routes-noacl-site-to-site"
         className="imagewrapper-big"/>
</p>

but you will need to turn off **Masquerade** from within the **Network Route**'s update dialog:

<p>
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/route-without-masquerading.png" alt="route-without-masquerading"
         className="imagewrapper-big"/>
</p>

Only one **Access Control Policy** is required, just like [above](#unidirectional-routing-peer-policy):

<p>
    <img src="/docs-static/img/how-to-guides/setup-site-to-site-access/acl-ping-to-local-only.png" alt="acl-ping-to-local-only"
         className="imagewrapper-big"/>
</p>

Having those 2 pieces of configuration in place we can confirm that the `ping` works:

```shell
kdn@pc ~> ssh local-01.lan "ip route | grep 192.168.100"
192.168.100.0/24 via 192.168.122.144 dev enp7s0 
kdn@pc ~> ssh local-01.lan "ping -c1 192.168.100.10"
PING 192.168.100.10 (192.168.100.10) 56(84) bytes of data.
64 bytes from 192.168.100.10: icmp_seq=1 ttl=62 time=0.897 ms

--- 192.168.100.10 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.897/0.897/0.897/0.000 ms
```

and that packets arrive unaltered on the remote end:

```shell
kdn@pc ~> ssh 192.168.100.10 -J vms.lan "sudo tcpdump -nvv -i any --immediate-mode -l icmp"
tcpdump: WARNING: any: That device doesn't support promiscuous mode
(Promiscuous mode not supported on the "any" device)
tcpdump: data link type LINUX_SLL2
tcpdump: listening on any, link-type LINUX_SLL2 (Linux cooked v2), snapshot length 262144 bytes
17:32:17.845428 enp7s0 In  IP (tos 0x0, ttl 62, id 56506, offset 0, flags [DF], proto ICMP (1), length 84)
    192.168.122.65 > 192.168.100.10: ICMP echo request, id 4480, seq 1, length 64
17:32:17.845468 enp7s0 Out IP (tos 0x0, ttl 64, id 51781, offset 0, flags [none], proto ICMP (1), length 84)
    192.168.100.10 > 192.168.122.65: ICMP echo reply, id 4480, seq 1, length 64
^C‚èé
```
